/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * virsh-sandbox API
 * API for managing virtual machine sandboxes using libvirt
 * OpenAPI spec version: 0.0.1-beta
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

import type {
  VirshSandboxInternalAnsibleAddTaskRequest,
  VirshSandboxInternalAnsibleAddTaskResponse,
  VirshSandboxInternalAnsibleCreatePlaybookRequest,
  VirshSandboxInternalAnsibleCreatePlaybookResponse,
  VirshSandboxInternalAnsibleExportPlaybookResponse,
  VirshSandboxInternalAnsibleGetPlaybookResponse,
  VirshSandboxInternalAnsibleListPlaybooksResponse,
  VirshSandboxInternalAnsibleReorderTasksRequest,
  VirshSandboxInternalAnsibleUpdateTaskRequest,
  VirshSandboxInternalAnsibleUpdateTaskResponse,
  VirshSandboxInternalErrorErrorResponse,
} from ".././model";

/**
 * Lists all Ansible playbooks
 * @summary List playbooks
 */
export const listPlaybooks = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VirshSandboxInternalAnsibleListPlaybooksResponse>> => {
  return axios.default.get(`/v1/ansible/playbooks`, options);
};

export const getListPlaybooksQueryKey = () => {
  return [`/v1/ansible/playbooks`] as const;
};

export const getListPlaybooksQueryOptions = <
  TData = Awaited<ReturnType<typeof listPlaybooks>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listPlaybooks>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListPlaybooksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listPlaybooks>>> = ({
    signal,
  }) => listPlaybooks({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listPlaybooks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPlaybooksQueryResult = NonNullable<
  Awaited<ReturnType<typeof listPlaybooks>>
>;
export type ListPlaybooksQueryError = AxiosError<unknown>;

export function useListPlaybooks<
  TData = Awaited<ReturnType<typeof listPlaybooks>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPlaybooks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlaybooks>>,
          TError,
          Awaited<ReturnType<typeof listPlaybooks>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPlaybooks<
  TData = Awaited<ReturnType<typeof listPlaybooks>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPlaybooks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlaybooks>>,
          TError,
          Awaited<ReturnType<typeof listPlaybooks>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPlaybooks<
  TData = Awaited<ReturnType<typeof listPlaybooks>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPlaybooks>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List playbooks
 */

export function useListPlaybooks<
  TData = Awaited<ReturnType<typeof listPlaybooks>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPlaybooks>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListPlaybooksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new Ansible playbook
 * @summary Create playbook
 */
export const createPlaybook = (
  virshSandboxInternalAnsibleCreatePlaybookRequest: VirshSandboxInternalAnsibleCreatePlaybookRequest,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<VirshSandboxInternalAnsibleCreatePlaybookResponse>
> => {
  return axios.default.post(
    `/v1/ansible/playbooks`,
    virshSandboxInternalAnsibleCreatePlaybookRequest,
    options,
  );
};

export const getCreatePlaybookMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPlaybook>>,
    TError,
    { data: VirshSandboxInternalAnsibleCreatePlaybookRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPlaybook>>,
  TError,
  { data: VirshSandboxInternalAnsibleCreatePlaybookRequest },
  TContext
> => {
  const mutationKey = ["createPlaybook"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPlaybook>>,
    { data: VirshSandboxInternalAnsibleCreatePlaybookRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPlaybook(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePlaybookMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPlaybook>>
>;
export type CreatePlaybookMutationBody =
  VirshSandboxInternalAnsibleCreatePlaybookRequest;
export type CreatePlaybookMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Create playbook
 */
export const useCreatePlaybook = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPlaybook>>,
      TError,
      { data: VirshSandboxInternalAnsibleCreatePlaybookRequest },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPlaybook>>,
  TError,
  { data: VirshSandboxInternalAnsibleCreatePlaybookRequest },
  TContext
> => {
  const mutationOptions = getCreatePlaybookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Deletes a playbook and all its tasks
 * @summary Delete playbook
 */
export const deletePlaybook = (
  playbookName: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.delete(`/v1/ansible/playbooks/${playbookName}`, options);
};

export const getDeletePlaybookMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePlaybook>>,
    TError,
    { playbookName: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePlaybook>>,
  TError,
  { playbookName: string },
  TContext
> => {
  const mutationKey = ["deletePlaybook"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePlaybook>>,
    { playbookName: string }
  > = (props) => {
    const { playbookName } = props ?? {};

    return deletePlaybook(playbookName, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePlaybookMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePlaybook>>
>;

export type DeletePlaybookMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Delete playbook
 */
export const useDeletePlaybook = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePlaybook>>,
      TError,
      { playbookName: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deletePlaybook>>,
  TError,
  { playbookName: string },
  TContext
> => {
  const mutationOptions = getDeletePlaybookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Gets a playbook and its tasks by name
 * @summary Get playbook
 */
export const getPlaybook = (
  playbookName: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VirshSandboxInternalAnsibleGetPlaybookResponse>> => {
  return axios.default.get(`/v1/ansible/playbooks/${playbookName}`, options);
};

export const getGetPlaybookQueryKey = (playbookName?: string) => {
  return [`/v1/ansible/playbooks/${playbookName}`] as const;
};

export const getGetPlaybookQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPlaybookQueryKey(playbookName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaybook>>> = ({
    signal,
  }) => getPlaybook(playbookName, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!playbookName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlaybook>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPlaybookQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlaybook>>
>;
export type GetPlaybookQueryError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

export function useGetPlaybook<
  TData = Awaited<ReturnType<typeof getPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlaybook>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaybook>>,
          TError,
          Awaited<ReturnType<typeof getPlaybook>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlaybook<
  TData = Awaited<ReturnType<typeof getPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlaybook>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaybook>>,
          TError,
          Awaited<ReturnType<typeof getPlaybook>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlaybook<
  TData = Awaited<ReturnType<typeof getPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get playbook
 */

export function useGetPlaybook<
  TData = Awaited<ReturnType<typeof getPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPlaybookQueryOptions(playbookName, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Exports a playbook as raw YAML
 * @summary Export playbook
 */
export const exportPlaybook = (
  playbookName: string,
  options?: AxiosRequestConfig,
): Promise<
  AxiosResponse<VirshSandboxInternalAnsibleExportPlaybookResponse>
> => {
  return axios.default.get(
    `/v1/ansible/playbooks/${playbookName}/export`,
    options,
  );
};

export const getExportPlaybookQueryKey = (playbookName?: string) => {
  return [`/v1/ansible/playbooks/${playbookName}/export`] as const;
};

export const getExportPlaybookQueryOptions = <
  TData = Awaited<ReturnType<typeof exportPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exportPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExportPlaybookQueryKey(playbookName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof exportPlaybook>>> = ({
    signal,
  }) => exportPlaybook(playbookName, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!playbookName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof exportPlaybook>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExportPlaybookQueryResult = NonNullable<
  Awaited<ReturnType<typeof exportPlaybook>>
>;
export type ExportPlaybookQueryError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

export function useExportPlaybook<
  TData = Awaited<ReturnType<typeof exportPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exportPlaybook>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportPlaybook>>,
          TError,
          Awaited<ReturnType<typeof exportPlaybook>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExportPlaybook<
  TData = Awaited<ReturnType<typeof exportPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exportPlaybook>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportPlaybook>>,
          TError,
          Awaited<ReturnType<typeof exportPlaybook>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExportPlaybook<
  TData = Awaited<ReturnType<typeof exportPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exportPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Export playbook
 */

export function useExportPlaybook<
  TData = Awaited<ReturnType<typeof exportPlaybook>>,
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
>(
  playbookName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof exportPlaybook>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getExportPlaybookQueryOptions(playbookName, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Adds a new task to an existing playbook
 * @summary Add task to playbook
 */
export const addPlaybookTask = (
  playbookName: string,
  virshSandboxInternalAnsibleAddTaskRequest: VirshSandboxInternalAnsibleAddTaskRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VirshSandboxInternalAnsibleAddTaskResponse>> => {
  return axios.default.post(
    `/v1/ansible/playbooks/${playbookName}/tasks`,
    virshSandboxInternalAnsibleAddTaskRequest,
    options,
  );
};

export const getAddPlaybookTaskMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPlaybookTask>>,
    TError,
    { playbookName: string; data: VirshSandboxInternalAnsibleAddTaskRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addPlaybookTask>>,
  TError,
  { playbookName: string; data: VirshSandboxInternalAnsibleAddTaskRequest },
  TContext
> => {
  const mutationKey = ["addPlaybookTask"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPlaybookTask>>,
    { playbookName: string; data: VirshSandboxInternalAnsibleAddTaskRequest }
  > = (props) => {
    const { playbookName, data } = props ?? {};

    return addPlaybookTask(playbookName, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddPlaybookTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof addPlaybookTask>>
>;
export type AddPlaybookTaskMutationBody =
  VirshSandboxInternalAnsibleAddTaskRequest;
export type AddPlaybookTaskMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Add task to playbook
 */
export const useAddPlaybookTask = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addPlaybookTask>>,
      TError,
      { playbookName: string; data: VirshSandboxInternalAnsibleAddTaskRequest },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addPlaybookTask>>,
  TError,
  { playbookName: string; data: VirshSandboxInternalAnsibleAddTaskRequest },
  TContext
> => {
  const mutationOptions = getAddPlaybookTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Removes a task from a playbook
 * @summary Delete task
 */
export const deletePlaybookTask = (
  playbookName: string,
  taskId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.delete(
    `/v1/ansible/playbooks/${playbookName}/tasks/${taskId}`,
    options,
  );
};

export const getDeletePlaybookTaskMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePlaybookTask>>,
    TError,
    { playbookName: string; taskId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePlaybookTask>>,
  TError,
  { playbookName: string; taskId: string },
  TContext
> => {
  const mutationKey = ["deletePlaybookTask"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePlaybookTask>>,
    { playbookName: string; taskId: string }
  > = (props) => {
    const { playbookName, taskId } = props ?? {};

    return deletePlaybookTask(playbookName, taskId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePlaybookTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePlaybookTask>>
>;

export type DeletePlaybookTaskMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Delete task
 */
export const useDeletePlaybookTask = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePlaybookTask>>,
      TError,
      { playbookName: string; taskId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deletePlaybookTask>>,
  TError,
  { playbookName: string; taskId: string },
  TContext
> => {
  const mutationOptions = getDeletePlaybookTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Updates an existing task in a playbook
 * @summary Update task
 */
export const updatePlaybookTask = (
  playbookName: string,
  taskId: string,
  virshSandboxInternalAnsibleUpdateTaskRequest: VirshSandboxInternalAnsibleUpdateTaskRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VirshSandboxInternalAnsibleUpdateTaskResponse>> => {
  return axios.default.put(
    `/v1/ansible/playbooks/${playbookName}/tasks/${taskId}`,
    virshSandboxInternalAnsibleUpdateTaskRequest,
    options,
  );
};

export const getUpdatePlaybookTaskMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePlaybookTask>>,
    TError,
    {
      playbookName: string;
      taskId: string;
      data: VirshSandboxInternalAnsibleUpdateTaskRequest;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePlaybookTask>>,
  TError,
  {
    playbookName: string;
    taskId: string;
    data: VirshSandboxInternalAnsibleUpdateTaskRequest;
  },
  TContext
> => {
  const mutationKey = ["updatePlaybookTask"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePlaybookTask>>,
    {
      playbookName: string;
      taskId: string;
      data: VirshSandboxInternalAnsibleUpdateTaskRequest;
    }
  > = (props) => {
    const { playbookName, taskId, data } = props ?? {};

    return updatePlaybookTask(playbookName, taskId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePlaybookTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePlaybookTask>>
>;
export type UpdatePlaybookTaskMutationBody =
  VirshSandboxInternalAnsibleUpdateTaskRequest;
export type UpdatePlaybookTaskMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Update task
 */
export const useUpdatePlaybookTask = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePlaybookTask>>,
      TError,
      {
        playbookName: string;
        taskId: string;
        data: VirshSandboxInternalAnsibleUpdateTaskRequest;
      },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePlaybookTask>>,
  TError,
  {
    playbookName: string;
    taskId: string;
    data: VirshSandboxInternalAnsibleUpdateTaskRequest;
  },
  TContext
> => {
  const mutationOptions = getUpdatePlaybookTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Reorders tasks in a playbook
 * @summary Reorder tasks
 */
export const reorderPlaybookTasks = (
  playbookName: string,
  virshSandboxInternalAnsibleReorderTasksRequest: VirshSandboxInternalAnsibleReorderTasksRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.patch(
    `/v1/ansible/playbooks/${playbookName}/tasks/reorder`,
    virshSandboxInternalAnsibleReorderTasksRequest,
    options,
  );
};

export const getReorderPlaybookTasksMutationOptions = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reorderPlaybookTasks>>,
    TError,
    {
      playbookName: string;
      data: VirshSandboxInternalAnsibleReorderTasksRequest;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reorderPlaybookTasks>>,
  TError,
  {
    playbookName: string;
    data: VirshSandboxInternalAnsibleReorderTasksRequest;
  },
  TContext
> => {
  const mutationKey = ["reorderPlaybookTasks"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorderPlaybookTasks>>,
    {
      playbookName: string;
      data: VirshSandboxInternalAnsibleReorderTasksRequest;
    }
  > = (props) => {
    const { playbookName, data } = props ?? {};

    return reorderPlaybookTasks(playbookName, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorderPlaybookTasksMutationResult = NonNullable<
  Awaited<ReturnType<typeof reorderPlaybookTasks>>
>;
export type ReorderPlaybookTasksMutationBody =
  VirshSandboxInternalAnsibleReorderTasksRequest;
export type ReorderPlaybookTasksMutationError =
  AxiosError<VirshSandboxInternalErrorErrorResponse>;

/**
 * @summary Reorder tasks
 */
export const useReorderPlaybookTasks = <
  TError = AxiosError<VirshSandboxInternalErrorErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reorderPlaybookTasks>>,
      TError,
      {
        playbookName: string;
        data: VirshSandboxInternalAnsibleReorderTasksRequest;
      },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reorderPlaybookTasks>>,
  TError,
  {
    playbookName: string;
    data: VirshSandboxInternalAnsibleReorderTasksRequest;
  },
  TContext
> => {
  const mutationOptions = getReorderPlaybookTasksMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
